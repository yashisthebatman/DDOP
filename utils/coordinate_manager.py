# ==============================================================================
# File: utils/coordinate_manager.py
# ==============================================================================
"""A centralized class for managing and validating coordinate systems."""

from config import AREA_BOUNDS, GRID_RESOLUTION, MIN_ALTITUDE, MAX_ALTITUDE

class CoordinateManager:
    """
    Manages conversions between world (lat, lon, alt) and grid (x, y, z)
    coordinates. Enforces all boundary checks and validation.
    """
    def __init__(self, grid_depth: int):
        self.lon_min, self.lat_min, self.lon_max, self.lat_max = AREA_BOUNDS
        self.grid_res = GRID_RESOLUTION
        self.min_alt = MIN_ALTITUDE
        self.max_alt = MAX_ALTITUDE
        
        # Pre-calculate grid dimensions
        lon_range = self.lon_max - self.lon_min
        lat_range = self.lat_max - self.lat_min
        self.grid_width = int(lon_range / self.grid_res) + 1
        self.grid_height = int(lat_range / self.grid_res) + 1
        self.grid_depth = grid_depth
        self.grid_dims = (self.grid_width, self.grid_height, self.grid_depth)
        
        # Pre-calculate altitude step for efficiency
        self.alt_range = self.max_alt - self.min_alt
        if self.grid_depth > 1:
            self.alt_step = self.alt_range / (self.grid_depth - 1)
        else:
            self.alt_step = 0 # Avoid division by zero for flat grids

    def world_to_grid(self, world_pos: tuple) -> tuple:
        """
        Safely converts world coordinates to grid coordinates.
        This is the primary safe conversion method with built-in validation.
        """
        lon, lat, alt = world_pos
        
        # Calculate raw grid indices
        grid_x = int((lon - self.lon_min) / self.grid_res)
        grid_y = int((lat - self.lat_min) / self.grid_res)
        
        if self.alt_step > 0:
            grid_z = int((alt - self.min_alt) / self.alt_step)
        else:
            grid_z = 0
        
        # Clamp coordinates to ensure they are always within valid grid bounds
        safe_x = max(0, min(grid_x, self.grid_width - 1))
        safe_y = max(0, min(grid_y, self.grid_height - 1))
        safe_z = max(0, min(grid_z, self.grid_depth - 1))
        
        return (safe_x, safe_y, safe_z)

    def grid_to_world(self, grid_pos: tuple) -> tuple:
        """
        Converts grid coordinates back to world coordinates.
        Assumes grid_pos is valid, as it should be generated by this system.
        """
        grid_x, grid_y, grid_z = grid_pos
        
        lon = self.lon_min + grid_x * self.grid_res
        lat = self.lat_min + grid_y * self.grid_res
        alt = self.min_alt + grid_z * self.alt_step
        
        return (lon, lat, alt)

    def is_valid_grid_position(self, grid_pos: tuple) -> bool:
        """
        Performs a comprehensive check to see if a grid position is within
        the defined boundaries of the grid.
        """
        x, y, z = grid_pos
        return (0 <= x < self.grid_width and
                0 <= y < self.grid_height and
                0 <= z < self.grid_depth)